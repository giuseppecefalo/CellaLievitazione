#include <Arduino.h>
#include <TFT_eSPI.h>
#include <XPT2046_Touchscreen.h>
#include <SPI.h>
#include "lvgl.h"
#include "actions.h"
#include "ui.h" // Include il file per Screen1, Button1, Label1, Arc1
#include <WiFi.h>
#include <time.h>
#include "screens.h"
#include "esp_wifi.h"
#include <esp_now.h>
#include <time.h>
#include <LittleFS.h>
#include <FS.h>
#include <vars.h> // Include il file per le variabili globali
#include "sht30.h" // Libreria per il sensore di umidit√† e temperatura SHT30

// i pin del sht30 sono definti nel file sht30.h
static bool sht30_ok = false;  // Flag per indicare se il sensore SHT30 √® inizializzato correttamente

// Le reti WiFi disponibili (SSID e password) sono memorizzate nella flash

/* Configurazioni di risoluzione del display con variabili del timer dello spegnimento del led*/
static const uint16_t screenWidth = 320;
static const uint16_t screenHeight = 240;

#define BACKLIGHT_PIN 21           // Definisce il pin per la retroilluminazione del display
#define BL_FREQ 5000
#define BL_RES  8   // 8 bit => 0..255

static int bl_channel = -1;   // channel allocato da ledcAttach


#define INACTIVITY_TIMEOUT 50000   // Tempo di inattivit√† in millisecondi (es. 10s)
unsigned long lastActivityTime = 0;
bool displayOn = true;
extern float set_temperature; // Variabile globale per la temperatura impostata
extern float set_umidita; // Variabile globale per l'umidit√† impostata

lv_obj_t *previous_page = NULL; // puntatore alla pagina che viene chiamata
lv_obj_t* WiFiList; // Puntatore alla lista delle reti WiFi
String selectedSSID = "";         // SSID selezionato

enum { SCREENBUFFER_SIZE_PIXELS = screenWidth * screenHeight / 10 };
static lv_color_t buf[SCREENBUFFER_SIZE_PIXELS];

TFT_eSPI tft = TFT_eSPI(screenWidth, screenHeight); // Istanza del display TFT

/* Configurazione touchscreen */
#define XPT2046_IRQ 36
#define XPT2046_MOSI 32
#define XPT2046_MISO 39
#define XPT2046_CLK 25
#define XPT2046_CS 33
SPIClass tsSpi = SPIClass(VSPI);
XPT2046_Touchscreen ts(XPT2046_CS, XPT2046_IRQ);

/* Prototipi delle funzioni presenti nel programma*/
extern "C" void salva_programmazione();
static inline void set_backlight(uint8_t level);
void updateWiFiIcon(); // funzione per la gestione delle icone del WiFi

/* Calibrazione touchscreen */
uint16_t touchScreenMinimumX = 200, touchScreenMaximumX = 3700;
uint16_t touchScreenMinimumY = 240, touchScreenMaximumY = 3800;

/* LED Config */
#define RED_LED_PIN 4 // rosso
#define GREEN_LED_PIN 16 // verde - 17 Blue
/*Altri pin */
#define PINCALDAIA 27 // Pin della caldaia blu 27
//#define PINCALDAIA 3 // Pin TX della caldaia 3, RX 1

/*Variabili del programma*/
bool accensioneCaldaia = false; // Accensione della caldaia
char ssid_attivo[33];// Variabili nuove di connessione WiFi da memorizzare nel file
char password_attiva[65];
bool connessioneWiFi = false; // flag per registrare lo stato della connessione WiFi
bool programAccensione = true; // flag per registrare l'attivazione del funzionamento secondo programmazione
float tMax = 20; // Temperatura massima 
float tMin = 18; // Temperatura minima 
float tempC = 0; // Temperatura rilavata dalla sonda DS18D20
byte displayFade = 0; // Variabile per il fade del display, in spegnimento ed accensione
char opzioni[1024] = {0};  // buffer globale per il dropdown delle reti WiFi

// Matrice di selezione (giorni √ó fasce orarie)
bool time_selected[7][48] = {false};

// variabili del giorno della settimana
int giorno_corrente = 0;  // 0 = Luned√¨, 6 = Domenica
lv_obj_t * label_giorno;
const char * giorni_settimana[] = {
    "Lun", "Mar", "Mer", "Gio", "Ven", "Sab", "Dom"
};

// Struttura dati per il comando
typedef struct struct_message {
  bool command;
} struct_message;

// Creazione dell'oggetto dati
struct_message myData;

/* Funzione per aggiornare il display */
void my_disp_flush(lv_display_t *disp, const lv_area_t *area, uint8_t *pixelmap) {
  uint32_t w = (area->x2 - area->x1 + 1);
  uint32_t h = (area->y2 - area->y1 + 1);

  if (LV_COLOR_16_SWAP) {
      size_t len = lv_area_get_size(area);
      lv_draw_sw_rgb565_swap(pixelmap, len);
  }

  tft.startWrite();
  tft.setAddrWindow(area->x1, area->y1, w, h);
  tft.pushColors((uint16_t *)pixelmap, w * h, true);
  tft.endWrite();

  lv_disp_flush_ready(disp);
}


/* Funzione per l'aggiornamento della luminosit√† del display quando c'√® attivit√†*/
void user_activity_detected() {
  lastActivityTime = millis();

  if (!displayOn) {
    // accensione immediata
    set_backlight(255);
    displayOn = true;
    displayFade = 0;
  }
}

/*
void user_activity_detected() {
  lastActivityTime = millis();   // reset timer
  if (!displayOn) {
  //  digitalWrite(BACKLIGHT_PIN, HIGH); // riaccendi retroilluminazione
  
  for(int x =0; x <=255; x++){
    analogWrite(BACKLIGHT_PIN, x);
    delay (10);
  }
  displayOn = true;
  }
}
*/

/* Controllo inattivit√† per lo spegnimento del dispaly */
void check_inactivity() {
  if (displayOn && (millis() - lastActivityTime > INACTIVITY_TIMEOUT)) {
    set_backlight(255 - displayFade);
    displayFade += 10;

    if (displayFade >= 255) {
      set_backlight(0);
      displayOn = false;
      displayFade = 255;
    }
  }
}

/*
void check_inactivity() {
  if (displayOn && (millis() - lastActivityTime > INACTIVITY_TIMEOUT)) {
    // digitalWrite(BACKLIGHT_PIN, LOW);  // spegni retroilluminazione
    analogWrite(BACKLIGHT_PIN, 255-displayFade);
    displayFade++;
    if (displayFade > 250){
      displayOn = false;
    }
}
}
*/

/* Funzione per leggere il touchscreen */
void my_touch_read(lv_indev_t *indev_drv, lv_indev_data_t *data) {
  if (ts.touched()) {
      TS_Point p = ts.getPoint();
      data->point.x = map(p.x, touchScreenMinimumX, touchScreenMaximumX, 0, screenWidth);
      data->point.y = map(p.y, touchScreenMinimumY, touchScreenMaximumY, 0, screenHeight);
      data->state = LV_INDEV_STATE_PR;
  } else {
      data->state = LV_INDEV_STATE_REL;
  }

  /* Funzione per rilevare l'uso del touch screen a schermo in pausa */
  if (data->state == LV_INDEV_STATE_PR) {
    user_activity_detected(); // attivit√† rilevata
  }
  
}

/* Callback per il timer di LVGL */
static uint32_t my_tick_get_cb(void) { return millis(); }

// Funzione per la scennerizzazione delle reti WiFi
extern "C"{

void scanWiFi() {
  // 1) reset buffer
  opzioni[0] = '\0';

  // 2) UI feedback immediato
  lv_label_set_text(objects.wi_fi_name, "Ricerca reti...");

  lv_timer_handler();
  delay(30);

  Serial.println("Inizio scansione WiFi...");

  // 3) se c'era una scan precedente "appesa", la pulisco
  int prev = WiFi.scanComplete();
  if (prev == WIFI_SCAN_RUNNING) {
    Serial.println("Scan precedente ancora in corso -> scanDelete()");
    WiFi.scanDelete();
    delay(80);
  } else if (prev >= 0) {
    // risultati vecchi presenti
    WiFi.scanDelete();
    delay(20);
  }

  // 4) porta lo stack WiFi in stato stabile
  WiFi.mode(WIFI_STA);
  WiFi.disconnect(true, true);   // pi√π robusto di disconnect()
  delay(200);

  WiFi.setSleep(false);          // riduce race/timing strani
  delay(30);

  // 5) scan con retry
  int n = WiFi.scanNetworks(/*async=*/false, /*show_hidden=*/true);

  if (n < 0) {
    Serial.printf("Scan fallita (1¬∞ tentativo), n=%d -> retry...\n", n);
    delay(300);
    WiFi.scanDelete();
    delay(50);

    n = WiFi.scanNetworks(false, true);
  }

  // 6) gestione errori definitiva
  if (n < 0) {
    Serial.printf("Scan fallita anche al 2¬∞ tentativo, n=%d\n", n);

    strncpy(opzioni, "Errore scan WiFi\nRiprova", sizeof(opzioni));
    opzioni[sizeof(opzioni) - 1] = '\0';

    lv_roller_set_options(objects.roller_wi_fi, opzioni, LV_ROLLER_MODE_NORMAL);
    lv_obj_invalidate(objects.roller_wi_fi);
    lv_timer_handler();
    return;
  }

  // 7) costruzione opzioni in modo safe
  if (n == 0) {
    Serial.println("Nessuna rete trovata.");
    strncpy(opzioni, "Nessuna rete trovata", sizeof(opzioni));
    opzioni[sizeof(opzioni) - 1] = '\0';
  } else {
    Serial.printf("Trovate %d reti:\n", n);

    size_t used = 0;
    opzioni[0] = '\0';

    for (int i = 0; i < n; ++i) {
      String ssidStr = WiFi.SSID(i);
      if (ssidStr.length() == 0) ssidStr = "<nascosta>";

      Serial.printf("  %d: %s (%d dBm)%s\n",
                    i + 1,
                    ssidStr.c_str(),
                    WiFi.RSSI(i),
                    (WiFi.encryptionType(i) == WIFI_AUTH_OPEN) ? " [open]" : "");

      // aggiungo "SSID\n" (o solo "SSID" all'ultima riga)
      const char* sep = (i == n - 1) ? "" : "\n";
      int written = snprintf(opzioni + used, sizeof(opzioni) - used,
                             "%s%s", ssidStr.c_str(), sep);

      if (written < 0) break;

      // se non ci sta tutto, tronco pulito e esco
      if ((size_t)written >= sizeof(opzioni) - used) {
        used = sizeof(opzioni) - 1;
        opzioni[used] = '\0';
        break;
      }
      used += (size_t)written;
    }
  }

  // 8) debug
  Serial.println("Debug");
  Serial.printf("scan n=%d, opzioni len=%d\n", n, (int)strlen(opzioni));
  Serial.println(opzioni);

  // 9) Popola roller + refresh UI
  lv_roller_set_options(objects.roller_wi_fi, opzioni, LV_ROLLER_MODE_NORMAL);
  lv_roller_set_selected(objects.roller_wi_fi, 0, LV_ANIM_OFF);
  lv_obj_invalidate(objects.roller_wi_fi);
  lv_timer_handler();

  // 10) libera memoria interna dello scan
  WiFi.scanDelete();

  Serial.println("Fine scansione.\n");
}

}

// Funzione per sanificare SSID e PASSWORD

static void sanitize_password(char *s) {
  if (!s) return;

  // Tronca al primo byte non ASCII stampabile (evita CR/LF, NBSP, UTF-8, controlli)
  for (size_t i = 0; s[i] != '\0'; i++) {
    uint8_t c = (uint8_t)s[i];
    if (c < 0x20 || c > 0x7E) {   // fuori ASCII stampabile
      s[i] = '\0';
      break;
    }
  }

  // Trim finale classico
  size_t n = strlen(s);
  while (n > 0) {
    char c = s[n - 1];
    if (c == ' ' || c == '\r' || c == '\n' || c == '\t') {
      s[n - 1] = '\0';
      n--;
    } else break;
  }
}

// Funzione di connessione WiFi
void connectToWiFi() {
  Serial.println("Tentativo di connessione WiFi...");
  connessioneWiFi = false;

  // Prova a connettersi alle credenziali memorizzate in memoria

  sanitize_password(ssid_attivo); // sanifica la password e ssid
  sanitize_password(password_attiva); // sanifica la password e ssid

  Serial.print("Connessione a: ");
  Serial.println(ssid_attivo);

  // (Consigliato) reset stato WiFi prima del tentativo
  WiFi.mode(WIFI_STA);
  WiFi.disconnect(true);
  delay(200);

  WiFi.begin(ssid_attivo, password_attiva);

  int tentativi = 0;
  const int maxTentativi = 20;  // 10 secondi (20 * 500ms)

  while (WiFi.status() != WL_CONNECTED && tentativi++ < maxTentativi) {
    delay(500);
    Serial.print(".");
  }

  if (WiFi.status() == WL_CONNECTED) {
    connessioneWiFi = true;
    Serial.print("\nConnesso a ");
    Serial.println(ssid_attivo);
    lv_label_set_text(objects.wi_fi_name, ssid_attivo); // Aggiorna l'etichetta con il nome della rete
    updateWiFiIcon(); // Aggiorna l'icona del WiFi

    // Salva solo se ha senso (es. vuoi persistere anche l‚Äôultima connessione ok)
    salva_programmazione();
    return;
  }

  // FALLIMENTO
  connessioneWiFi = false;
  Serial.println("\nConnessione FALLITA. WiFi OFF.");
  WiFi.disconnect(true);
  WiFi.mode(WIFI_OFF);
  Serial.println("Nessuna rete disponibile. WiFi OFF.");
}

// funzione per la gestione delle icone del WiFi
void updateWiFiIcon() {
//  lv_obj_clear_flag(objects.wi_fi_on, LV_OBJ_FLAG_HIDDEN);
  if (connessioneWiFi) {
    // Nasconde l‚Äôicona X
    lv_obj_add_flag(objects.wi_fi_x, LV_OBJ_FLAG_HIDDEN);

    // Mostra il nome della rete
    lv_label_set_text(objects.wi_fi_name, ssid_attivo);
 
  } else {
    // Mostra l‚Äôicona X
    lv_obj_clear_flag(objects.wi_fi_x, LV_OBJ_FLAG_HIDDEN);

    // Mostra stato non connesso
    lv_label_set_text(objects.wi_fi_name, "Non connesso");
  }
}

// Verifica dello stato della connessione
void checkWiFiStatus() {
  if (WiFi.status() != WL_CONNECTED) {
      Serial.println("WiFi perso! Tentativo di riconnessione...");
      lv_obj_clear_flag(objects.wi_fi_x, LV_OBJ_FLAG_HIDDEN); // Mostra il widget
      connectToWiFi();
  } else {
      lv_obj_add_flag(objects.wi_fi_x, LV_OBJ_FLAG_HIDDEN); // Nascondi il widget
  }
  updateWiFiIcon();
}

// Crea il wrapper per LVGL - serve per chiamare la funzione di controllo WiFi
void checkWiFiStatus_cb(lv_timer_t * t) {
    (void)t;              // evita warning
    checkWiFiStatus();    // chiama la tua funzione originale
}

// Stampa le variabili del programma
void aggiornaVariabili(lv_timer_t *timer){
  Serial.print ("Accensione caldaia ");
  Serial.println (accensioneCaldaia);
  Serial.print ("Temparatura Massima ");
  Serial.println (tMax);
  Serial.print ("Temparatura Minima ");
  Serial.println (tMin);
  Serial.print("Temperatura: ");
  Serial.printf("set_temperature = %.2f\n", (double)set_temperature);
  // Serial.println("¬∞C");
  Serial.print("Connessione WiFi: ");
  Serial.println(ssid_attivo);
  Serial.print ("Programmazione ");
  Serial.println (programAccensione);

 // callback di aggiornamento della temperatuta, vale come sopra
  action_temp_label_update_event_handler(NULL);
  Serial.print ("Accensione caldaia: ");
  Serial.println(accensioneCaldaia ? "ON" : "OFF");
//  sendCaldaiaCommand(accensioneCaldaia); // invio del comando di accensione/spegnimento della caldaia
}

void updateClockTask(lv_timer_t *timer) {
  struct tm timeinfo;

  // Controlla e ripristina la connessione WiFi solo se necessario
  bool wifiAvailable = (WiFi.status() == WL_CONNECTED);
  if (!wifiAvailable) {
      Serial.println("‚ö†Ô∏è WiFi disconnesso. Tentativo di riconnessione...");
      connectToWiFi();
      wifiAvailable = (WiFi.status() == WL_CONNECTED); // Controlla di nuovo dopo il tentativo
  }

  // Se il WiFi √® disponibile, prova a sincronizzare l'orario con NTP
  if (wifiAvailable) {
      if (!getLocalTime(&timeinfo)) {
          Serial.println("‚ùå Errore nel recupero dell'ora NTP! Uso RTC interno.");
      }
  } else {
      Serial.println("‚ö†Ô∏è WiFi non disponibile. Uso RTC interno.");
      time_t now;
      time(&now);  // Recupera l'ora dall'RTC interno
      localtime_r(&now, &timeinfo);
  }

  // Array dei nomi dei giorni in italiano
  const char* giorniSettimana[] = {
      "Dom", "Lun", "Mar", "Mer", "Gio", "Ven", "Sab"
  };

  // Buffer per data completa: "Luned√¨, 08/04/2024 - 14:35"
  char dataOraStr[64];
  snprintf(dataOraStr, sizeof(dataOraStr),
           "%s, %02d/%02d/%04d - %02d:%02d",
           giorniSettimana[timeinfo.tm_wday],
           timeinfo.tm_mday,
           timeinfo.tm_mon + 1,
           timeinfo.tm_year + 1900,
           timeinfo.tm_hour,
           timeinfo.tm_min);

  Serial.printf("‚úÖ Orologio aggiornato: %s\n", dataOraStr);  // Debug

  // Verifica se il puntatore √® NULL
  if (objects.id_clock_label == NULL || objects.id_clock_label_2 == NULL) {
      Serial.println("‚ö†Ô∏è Errore: label non inizializzata! Reset evitato.");
      return;
  }

  // Aggiorna entrambe le label con data e ora
  lv_label_set_text(objects.id_clock_label, dataOraStr);
  lv_label_set_text(objects.id_clock_label_2, dataOraStr);
}
extern "C" {

  void gestisciAccensioneCaldaia(lv_timer_t* timer) {
    struct tm timeinfo;
    if (!getLocalTime(&timeinfo)) {
        Serial.println("‚ùå Errore nel recupero dell'orario - Caldaia spenta");
        digitalWrite(PINCALDAIA, LOW);
        lv_label_set_text(objects.programmazione, "Errore orario");
        return;
    }

    int giorno = (timeinfo.tm_wday + 6) % 7;  // Luned√¨ = 0, Domenica = 6
    int minutiTotali = timeinfo.tm_hour * 60 + timeinfo.tm_min;
    int slot = minutiTotali / 30;

    bool accensioneCaldaia = false;

    if (programAccensione) {
        // Modalit√† PROGRAMMAZIONE
        Serial.println("üß† Modalit√†: Programmazione");

        if (giorno >= 0 && giorno < 7 && slot >= 0 && slot < 48) {
            bool slotAttivo = time_selected[giorno][slot];

            if (slotAttivo && tempC <= tMax) {
                accensioneCaldaia = true;
                Serial.println("üî• Slot attivo e temperatura sotto tMax ‚Üí Caldaia ACCESA");
              //  lv_obj_clear_flag(objects.fiamma, LV_OBJ_FLAG_HIDDEN);  // Rendi visibile l'oggetto Fiamma
            } else {
              //  lv_obj_add_flag(objects.fiamma, LV_OBJ_FLAG_HIDDEN);    // Rendi invisibile l'oggetto Fiamma
                Serial.println("üí§ Slot non attivo o temperatura sopra tMax ‚Üí Caldaia SPENTA");
            }

            lv_label_set_text(objects.programmazione, slotAttivo ? "Programmazione ON" : "Programmazione OFF");
        } else {
            Serial.println("‚ö†Ô∏è Indici fuori range - Caldaia spenta per sicurezza");
            lv_label_set_text(objects.programmazione, "Programmazione OFF");
        }

    } else {
        // Modalit√† MANUALE
        Serial.println("üõ† Modalit√†: Manuale");

        if (tempC < tMax) {
          accensioneCaldaia = true;
          Serial.println("üî• Temperatura sotto tMin ‚Üí Caldaia ACCESA (Manuale)");
        //  lv_obj_clear_flag(objects.fiamma, LV_OBJ_FLAG_HIDDEN);  // Mostra la fiamma
        }
        else {
          accensioneCaldaia = false;
          Serial.println("üì¥ Temperatura sopra tMax ‚Üí Caldaia SPENTA (Manuale)");
        //  lv_obj_add_flag(objects.fiamma, LV_OBJ_FLAG_HIDDEN);    // Nascondi la fiamma
        }

        lv_label_set_text(objects.programmazione, "Manuale");
    }

    digitalWrite(PINCALDAIA, accensioneCaldaia ? HIGH : LOW);
  }
}

// Funzione di registrazione dei dati in memoria flash

extern "C" void salva_programmazione() {
  fs::File file = LittleFS.open("/programmazione.bin", "wb"); // binario
  if (!file) {
    Serial.println("‚ùå Errore apertura file per scrittura.");
    return;
  }

  // Scrivi tMin e tMax
  file.write((uint8_t*)&tMin, sizeof(float));
  file.write((uint8_t*)&tMax, sizeof(float));

  // Salva 7 giorni √ó 6 byte
  for (int giorno = 0; giorno < 7; giorno++) {
    uint8_t buffer[6] = {0};
    for (int slot = 0; slot < 48; slot++) {
      if (time_selected[giorno][slot]) {
        int byte_index = slot / 8;
        int bit_index  = slot % 8;
        buffer[byte_index] |= (1 << bit_index);
      }
    }
    file.write(buffer, 6);
  }

  // ‚úÖ Salva SSID attivo (max 32)
  uint8_t ssid_len = (uint8_t)strlen(ssid_attivo);
  if (ssid_len > 32) ssid_len = 32;
  file.write((const uint8_t*)&ssid_len, 1);
  if (ssid_len > 0) file.write((const uint8_t*)ssid_attivo, ssid_len);

  // ‚úÖ Salva Password attiva (max 63)
  uint8_t pwd_len = (uint8_t)strlen(password_attiva);
  if (pwd_len > 63) pwd_len = 63;
  file.write((const uint8_t*)&pwd_len, 1);
  if (pwd_len > 0) file.write((const uint8_t*)password_attiva, pwd_len);

  file.close();

  Serial.printf("‚úÖ Salvataggio completato. SSID_len=%u PWD_len=%u\n", ssid_len, pwd_len);
}
  
// nuova funzione di connessione alla rete WiFi
// Questa funzione √® richiamata da action.c

extern "C" void connect_to_wifi(const char* ssid, const char* password)
{
    Serial.print("Connessione a: ");
    Serial.println(ssid);

    WiFi.begin(ssid, password);

    char msg[128];
    snprintf(msg, sizeof(msg), "Connessione a: %s", ssid);
    lv_label_set_text(objects.programmazione, msg);
    lv_obj_add_flag(objects.wi_fi_x, LV_OBJ_FLAG_HIDDEN);

    unsigned long startAttemptTime = millis();
    const unsigned long timeout = 10000;

    while (WiFi.status() != WL_CONNECTED && millis() - startAttemptTime < timeout) {
        delay(500);
    }

    if (WiFi.status() == WL_CONNECTED) {
        // ‚úÖ copia credenziali ‚Äúbuone‚Äù nelle globali prima di salvare
        strncpy(ssid_attivo, ssid, sizeof(ssid_attivo) - 1);
        ssid_attivo[sizeof(ssid_attivo) - 1] = '\0';

        strncpy(password_attiva, password, sizeof(password_attiva) - 1);
        password_attiva[sizeof(password_attiva) - 1] = '\0';

        Serial.printf("DEBUG: ssid_attivo='%s' pwd_len=%d\n",
                      ssid_attivo, (int)strlen(password_attiva));

        salva_programmazione();

        snprintf(msg, sizeof(msg), "Connesso a: %s", ssid);
    } else {
        snprintf(msg, sizeof(msg), "Connessione fallita.");
    }

    lv_label_set_text(objects.programmazione, msg);
}

// Carica i dati della flash all'accensione 

#include <string.h>  // memset

extern char ssid_attivo[33];
extern char password_attiva[65];

extern "C" void carica_programmazione() {
  fs::File file = LittleFS.open("/programmazione.bin", "rb");
  if (!file) {
    Serial.println("‚ö†Ô∏è File non trovato, caricamento saltato.");
    ssid_attivo[0] = '\0';
    password_attiva[0] = '\0';
    return;
  }

  // Leggi tMin e tMax
  if (file.read((uint8_t*)&tMin, sizeof(float)) != sizeof(float) ||
      file.read((uint8_t*)&tMax, sizeof(float)) != sizeof(float)) {
    Serial.println("‚ùå Errore lettura tMin/tMax (file corto o corrotto)");
    file.close();
    ssid_attivo[0] = '\0';
    password_attiva[0] = '\0';
    return;
  }

  // Ricostruisci l'array dei 7 giorni
  for (int giorno = 0; giorno < 7; giorno++) {
    uint8_t buffer[6];
    if (file.read(buffer, 6) != 6) {
      Serial.printf("‚ùå Errore lettura giorno %d\n", giorno);
      file.close();
      ssid_attivo[0] = '\0';
      password_attiva[0] = '\0';
      return;
    }

    for (int slot = 0; slot < 48; slot++) {
      int byte_index = slot / 8;
      int bit_index  = slot % 8;
      time_selected[giorno][slot] = (buffer[byte_index] >> bit_index) & 0x01;
    }
  }

  // --- Credenziali WiFi (opzionali, file nuovo) ---
  // Default: vuote se non presenti
  ssid_attivo[0] = '\0';
  password_attiva[0] = '\0';

  if (file.available() > 0) {
    // SSID
    uint8_t ssid_len = 0;
    if (file.read(&ssid_len, 1) == 1 && ssid_len <= 32 && file.available() >= ssid_len) {
      memset(ssid_attivo, 0, sizeof(ssid_attivo));
      if (ssid_len > 0) file.read((uint8_t*)ssid_attivo, ssid_len);
      ssid_attivo[ssid_len] = '\0';

   // Password
    uint8_t pwd_len = 0;
    if (file.read(&pwd_len, 1) == 1 && pwd_len <= 63 && file.available() >= pwd_len) {
    memset(password_attiva, 0, sizeof(password_attiva));

    if (pwd_len > 0) {
        file.read((uint8_t*)password_attiva, pwd_len);
    }

    // Terminatore sicuro
    password_attiva[pwd_len] = '\0';

    // Lunghezza reale (non fidarti ciecamente di pwd_len)
    size_t real_len = strnlen(password_attiva, sizeof(password_attiva) - 1);

    // Fix mirato: se l'ultimo carattere risulta duplicato (es. "...dd"), tronca di 1
    if (real_len >= 2 && password_attiva[real_len - 1] == password_attiva[real_len - 2]) {
        password_attiva[real_len - 1] = '\0';
        real_len--;
    }

    Serial.printf("‚úÖ Credenziali caricate. SSID='%s' pwd_len_file=%u pwd_len_real=%u\n",
                    ssid_attivo, pwd_len, (unsigned)real_len);

    } else {
    Serial.println("‚ö†Ô∏è Password non valida o mancante nel file (ignoro credenziali).");
    ssid_attivo[0] = '\0';
    password_attiva[0] = '\0';
    }
    
    } else {
      Serial.println("‚ö†Ô∏è SSID non valido o mancante nel file (ignoro credenziali).");
    }
  } else {
    Serial.println("‚ÑπÔ∏è Nessuna credenziale WiFi nel file (formato vecchio).");
  }

  file.close();

  Serial.printf("‚úÖ Programmazione caricata. tMin: %.2f¬∞C, tMax: %.2f¬∞C\n", tMin, tMax);
}


// Aggiorna i rollers delle temperature
/*
void init_temp_rollers() {
  if (objects.t_min == NULL || objects.t_max == NULL) {
      Serial.println("‚ùå Roller non inizializzati.");
      return;
  }

  int count_min = lv_roller_get_option_cnt(objects.t_min);
  int count_max = lv_roller_get_option_cnt(objects.t_max);
  Serial.printf("‚ÑπÔ∏è Roller t_min: %d opzioni, t_max: %d opzioni\n", count_min, count_max);

  int32_t index_min = (int)((tMin - 15.0f) / 0.5f);
  int32_t index_max = (int)((tMax - 19.5f) / 0.5f);

  if (index_min < 0 || index_min >= count_min) {
      Serial.printf("‚ùå tMin index %d fuori range (0‚Äì%d)\n", index_min, count_min - 1);
      return;
  }

  if (index_max < 0 || index_max >= count_max) {
      Serial.printf("‚ùå tMax index %d fuori range (0‚Äì%d)\n", index_max, count_max - 1);
      return;
  }

  lv_roller_set_selected(objects.t_min, index_min, LV_ANIM_OFF);
  lv_roller_set_selected(objects.t_max, index_max, LV_ANIM_OFF);

  Serial.printf("‚úÖ Roller impostati: tMin %.1f ‚Üí %d, tMax %.1f ‚Üí %d\n", tMin, index_min, tMax, index_max);
}
*/
// Dump completo di /programmazione.bin e blocco del programma
void debug_dump_programmazione_e_blocca() {
  Serial.println("\n===== DEBUG PROGRAMMAZIONE (DUMP FILE) =====");

  if (!LittleFS.exists("/programmazione.bin")) {
    Serial.println("‚ùå /programmazione.bin NON esiste");
    while (true) delay(1000);
  }

  fs::File file = LittleFS.open("/programmazione.bin", "rb");
  if (!file) {
    Serial.println("‚ùå Errore apertura file");
    while (true) delay(1000);
  }

  Serial.printf("Dimensione file: %u byte\n", (unsigned)file.size());

  // --- tMin / tMax ---
  float dbg_tMin = 0, dbg_tMax = 0;
  file.read((uint8_t*)&dbg_tMin, sizeof(float));
  file.read((uint8_t*)&dbg_tMax, sizeof(float));
  Serial.printf("tMin = %.2f\n", dbg_tMin);
  Serial.printf("tMax = %.2f\n", dbg_tMax);

  // --- Calendario ---
  for (int giorno = 0; giorno < 7; giorno++) {
    uint8_t buffer[6];
    file.read(buffer, 6);

    Serial.printf("Giorno %d bitmap: ", giorno);
    for (int i = 0; i < 6; i++) {
      Serial.printf("%02X ", buffer[i]);
    }
    Serial.println();

    Serial.print("  Slot attivi: ");
    bool any = false;
    for (int slot = 0; slot < 48; slot++) {
      int b = slot / 8;
      int bit = slot % 8;
      if (buffer[b] & (1 << bit)) {
        Serial.printf("%d ", slot);
        any = true;
      }
    }
    if (!any) Serial.print("(nessuno)");
    Serial.println();
  }

  // --- SSID ---
  uint8_t ssid_len = 0;
  file.read(&ssid_len, 1);

  char ssid_buf[33] = {0};
  if (ssid_len > 0 && ssid_len <= 32) {
    file.read((uint8_t*)ssid_buf, ssid_len);
    ssid_buf[ssid_len] = '\0';
  }

  Serial.printf("SSID salvato: '%s' (len=%u)\n", ssid_buf, ssid_len);

  // --- PASSWORD ---
  uint8_t pwd_len = 0;
  file.read(&pwd_len, 1);

  char pwd_buf[65] = {0};
  if (pwd_len > 0 && pwd_len <= 63) {
    file.read((uint8_t*)pwd_buf, pwd_len);
    pwd_buf[pwd_len] = '\0';
  }

  Serial.println("=== DEBUG PASSWORD (TESTUALE) ===");
  Serial.print("PWD: >");
  Serial.print(pwd_buf);
  Serial.println("<");
  Serial.printf("PWD length = %u\n", pwd_len);

  Serial.println("=== DEBUG PASSWORD (HEX) ===");
  for (int i = 0; i < pwd_len; i++) {
    uint8_t c = (uint8_t)pwd_buf[i];
    Serial.printf("[%02d] 0x%02X '%c'\n",
                  i,
                  c,
                  (c >= 32 && c <= 126) ? c : '.');
  }

  if (pwd_len > 0) {
    Serial.printf("ULTIMO BYTE: index=%d value=0x%02X\n",
                  pwd_len - 1,
                  (uint8_t)pwd_buf[pwd_len - 1]);
  }

  Serial.printf("Byte rimanenti dopo lettura: %d\n", file.available());

  file.close();

  Serial.println("===== FINE DUMP =====");
  Serial.println("‚õî Programma bloccato per debug.");

  while (true) delay(1000);
}


// Debug WiFi


#include <WiFi.h>

static void setupWiFiDebugEvents() {
  WiFi.onEvent([](WiFiEvent_t event, WiFiEventInfo_t info) {
    switch (event) {
      case ARDUINO_EVENT_WIFI_STA_START:
        Serial.println("[WiFi] STA_START");
        break;

      case ARDUINO_EVENT_WIFI_STA_CONNECTED:
        Serial.println("[WiFi] STA_CONNECTED (AP trovato, associato)");
        break;

      case ARDUINO_EVENT_WIFI_STA_GOT_IP:
        Serial.print("[WiFi] GOT_IP: ");
        Serial.println(WiFi.localIP());
        break;

      case ARDUINO_EVENT_WIFI_STA_DISCONNECTED:
        Serial.printf("[WiFi] STA_DISCONNECTED reason=%d\n", info.wifi_sta_disconnected.reason);
        break;

      default:
        // Serial.printf("[WiFi] event=%d\n", event);
        break;
    }
  });
}

// SHT30 sensor reading timer callback
static void sht30_timer_cb(lv_timer_t *t) {
  if (!sht30_ok) return;

  SHT30Reading r = sht30_read(Wire, SHT30_DEFAULT_ADDR); // indirizzo di default
  if (!r.ok) return;

  Serial.printf("T=%.2f C  H=%.1f %%\n",
                r.temperatureC,
                r.humidityRH);
  
  // Aggiorna le etichette della UI
  static char bufT[16];
  static char bufH[16];

  snprintf(bufT, sizeof(bufT), "%.1f", r.temperatureC);
  snprintf(bufH, sizeof(bufH), "%.0f", r.humidityRH);

  lv_label_set_text(objects.temperatura_interna, bufT);// Aggiorna l'etichetta con il valore della temperatura
  lv_label_set_text(objects.umidita_interna, bufH);// Aggiorna l'etichetta con il valore dell'umidit√†
}

// funzione helper per il backlight
static inline void set_backlight(uint8_t level) {
  // level: 0..255
  ledcWrite(BACKLIGHT_PIN, level);
}

// Funzione di setup
void setup() {
  // Disabilita il buffering della stdout per printf()
  setvbuf(stdout, NULL, _IONBF, 0);

  // Imposta il pin 21 per evitare un errore di derivante da una chiamata prima che venisse configurato come gpio
  pinMode(BACKLIGHT_PIN, OUTPUT);
  digitalWrite(BACKLIGHT_PIN, HIGH);

  Serial.begin(115200);


// inizializza il bus I2C per il sensore SHT30

  bool ok = sht30_begin(); // usa default CYD: SDA27 SCL22 freq 10k addr 0x44
  Serial.println(ok ? "SHT30 trovato" : "SHT30 NON trovato");

//    LittleFS.begin(); // Inizializza la memoria flash per la registrazione dei dati di porgrammazione
//    carica_programmazione();  // ‚úÖ Caricamento dei dati salvati

    bool fs_ok = LittleFS.begin(true);   // true = format se mount fallisce
    Serial.printf("LittleFS begin: %s\n", fs_ok ? "OK" : "FAIL");

    if (fs_ok) {
    carica_programmazione();
//    debug_dump_programmazione_e_blocca();  // Debug del file di porgrammazione, stampa e blocca il programma
    } else {
    Serial.println("‚ùå LittleFS KO: salto carica_programmazione e blocco i salvataggi.");
    }


// setupWiFiDebugEvents();

        
  //  init_slot_buttons(); // aggiorna 
  //  aggiorna_button_program_page(); // aggiorna i button 
    Serial.println("ESP32 avviato");
    lv_init();

   // Imposta il GPIO come accensione caldaia
    pinMode(PINCALDAIA, OUTPUT);

    // Configura il tempo via NTP integrando il controllo dell'ora legale usando la libreria time.h
    configTzTime("CET-1CEST,M3.5.0/2,M10.5.0/3", "pool.ntp.org");

    // Inizializzazione touchscreen
    tsSpi.begin(XPT2046_CLK, XPT2046_MISO, XPT2046_MOSI, XPT2046_CS);
    ts.begin(tsSpi);
    ts.setRotation(1);

    // Inizializzazione display
    tft.begin();
    tft.setRotation(1);

    // Configurazione di LVGL per il display
    static lv_disp_t *disp;
    disp = lv_display_create(screenWidth, screenHeight);
    lv_display_set_buffers(disp, buf, NULL, SCREENBUFFER_SIZE_PIXELS * sizeof(lv_color_t), LV_DISPLAY_RENDER_MODE_PARTIAL);
    lv_display_set_flush_cb(disp, my_disp_flush);

    // Configurazione touchscreen come input device per LVGL
    lv_indev_t *touch_indev = lv_indev_create();
    lv_indev_set_type(touch_indev, LV_INDEV_TYPE_POINTER);
    lv_indev_set_read_cb(touch_indev, my_touch_read);

/*
  // Inizializza la luminosit√† del display
  bl_channel = ledcAttach(BACKLIGHT_PIN, BL_FREQ, BL_RES);
    if (bl_channel < 0) {
      Serial.println("ERRORE: ledcAttach fallito per backlight!");
    } else {
      ledcWrite(BACKLIGHT_PIN, 0);   // oppure 255, vedi nota sotto
    }
*/
    // Imposta il callback per il timer LVGL
    lv_tick_set_cb(my_tick_get_cb);

    // Inizializza UI definita in ui.h/ui.c
    ui_init();

    // Imposta la modalit√† di connessione al WiFi - IMPORTANTE, siccome viene invocata una funzione LVGL, √® importante che la funzione venga chiamata dopo l'inizializzazione della UI
    WiFi.mode(WIFI_STA);  // Mantiene la modalit√† STA per ESP-NOW e verifica se √® istallato correttamente
    connectToWiFi(); // accede alla funzione di connessione ai diversi hotspot

    // usa SOLO i default del .h
    sht30_ok = sht30_begin();

    Serial.println(sht30_ok ? "SHT30 OK" : "SHT30 NON OK");

    lv_timer_create(sht30_timer_cb, 2000, NULL);

    // inizializzazione dei rollers alla temepratura impostata in memoria, possibile solo dopo inizializzazione della pagina
    //    init_temp_rollers(); // aggiorna i rollers

    // Crea un timer che chiama aggiornaVariabili ogni 2 secondi
    lv_timer_create(aggiornaVariabili, 2000, NULL);

    // Crea un timer che chiama updateClockTask ogni 60 secondi
    lv_timer_create(updateClockTask, 60000, NULL);

    // Chiama la funzione di verifica della programmazione ogni 60 secondi
    lv_timer_create(gestisciAccensioneCaldaia, 60000, NULL);  // ogni 60 secondi

    // Chiama la funzione di controllo dello stato della connessione WiFi ogni 60 secondi
    lv_timer_create(checkWiFiStatus_cb, 60000, NULL);  // ogni 60 secondi
  
}

void loop() {
  lv_task_handler();  // Mantiene aggiornata la GUI
//  lv_timer_handler(); // Aggiorna LVGL
  check_inactivity();  // Controlla inattivit√†
  ui_tick();          // Aggiorna la UI
//  tick_screen_main();
  delay(50);
   // Chiama la funzione per disegnare i 96 cavalieri
  // crea_cerchio_di_label(lv_scr_act());
}
